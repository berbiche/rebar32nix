-module(rebar32nix).

%% API exports
-export([main/1]).

-define(rebar_lock_version, "1.1.0").
-define(hex_registry_uri, "https://repo.hex.pm/tarballs/").
-define(nix_prefetch_url, "nix-prefetch-url").
-define(nix_prefetch_git, "nix-prefetch-git").

-type dependency() :: {hex, Name::string(), Vsn::string()}
                   |  {git, Name::string(), Repo::string(), Meta::tuple()}.


main(Args) ->
    %% io:format("Args: ~p~n", [Args]),
    {ok, {Opts, _}} = getopt:parse(opts_list(), Args),
    case proplists:get_bool(help, Opts) of
        true -> getopt:usage(opts_list(), "rebar32nix");
        false ->
            Path = filename:absname(proplists:get_value(file, Opts)),
            true = file:is_regular(Path),
            ReleaseType = proplists:get_value(release_type, Opts),
            app(Path, ReleaseType, Args)
    end,
    erlang:halt(0).

-spec app(string(), string(), tuple()) -> ok.
app(ProjectSource, ReleaseType, Args) ->
    _ = application:load(rebar32nix),
    {ok, {application, AppName, List}} = app_src(ProjectSource),
    Vsn = proplists:get_value(vsn, List),
    Deps = fetch_deps(ProjectSource),
    App = #{
            name => AppName,
            vsn => Vsn,
            src => ProjectSource,
            deps => Deps,
            release_type => ReleaseType
           },
    Doc = prettypr:above(header(Args), nix_formatter:new(App)),
    io:format("~s", [prettypr:format(Doc)]),
    ok.

%%====================================================================
%% Internal functions
%%====================================================================
opts_list() ->
    [
     %% {Name,      ShortOpt,  LongOpt,        ArgSpec,         HelpMsg}
     {help,         $h,        "help",         undefined,       "Print this help."},
     {version,      $v,        "version",      undefined,       "Show version information."},
     {release_type, undefined, "release-type", {atom, release}, "Generate either a release or an escript."},
     {file,         undefined, undefined,      string,          "Input file"}
    ].

-spec header([string()]) -> prettypr:document().
header(Args) ->
    ArgsDoc = lists:map(fun prettypr:text/1, Args),
    {ok, Vsn} = application:get_key(rebar32nix, vsn),
    Docs = [
            prettypr:text("# Generated by rebar32nix"),
            prettypr:beside(prettypr:text(Vsn), prettypr:text(":")),
            prettypr:text("rebar32nix")
            | ArgsDoc
           ],
    Docs1 = lists:join(prettypr:text(" "), Docs),
    lists:foldr(fun prettypr:beside/2, prettypr:empty(), Docs1).

-spec app_src(string()) -> {ok, term()}.
app_src(ProjectSource) ->
    {ok, Files} = file:list_dir(ProjectSource),
    [FileName] = lists:filter(fun(F) ->
                                 case re:run(F, "\.app\.src$") of
                                     {match, _} -> true;
                                     _ -> false
                                 end
                              end, Files),
    FullPath = unicode:characters_to_list([ProjectSource, "/", FileName]),
    file:script(FullPath).

-spec fetch_deps() -> [nix_formatter:resolvedDependency()].
-spec fetch_deps({[dependency()], [dependency()]}) -> [nix_formatter:resolvedDependency()].
fetch_deps() ->
    Deps = get_deps_list("./src"),
    exec:start([]),
    AllDeps = fetch_deps(Deps),
    exec:stop().
fetch_deps({PublicDeps, PrivateDeps}) ->
    % Handle the "non-recursive" deps first. What is meant by non-recursive
    % is that these deps. will not depend on private dependencies.

    [].

-spec get_deps_list(string) -> {[dependency()], [dependency()]}.
get_deps_list(Path) ->
    Filename = filename:absname_join(filename:absname(Path), "rebar.lock"),
    % case Filename of
    case filelib:is_regular(Filename) of
        true ->
            {ok, Lock} = file:consult(Filename),
            DepsList = proplists:get_value(rebar_lock_version, Lock, []);
        false ->
            DepsList = []
    end,
    PublicDeps = lists:map(fun convert_dep/1, DepsList),
    PrivateDepsToVisit = lists:filter(fun is_private_git_repo/1, DepsList),
    {PublicDeps, PrivateDepsToVisit}.

-spec convert_dep({string(), tuple(), any()}) -> dependency().
convert_dep({Name, {pkg, _, Vsn}, _}) ->
    {hex, Name, Vsn};
convert_dep({Name, {git, Repo, Meta}, _}) ->
    {git, Name, Repo, Meta}.

-spec is_private_git_repo(dependency()) -> boolean().
is_private_git_repo({git, _, "ssh://" ++ _, _}) -> true;
is_private_git_repo(_) -> false.

%%====================================================================
%% Worker functions
%%====================================================================
add_work() -> {ok}.

%%====================================================================
%% Fetcher functions
%%====================================================================
-spec hex_sha256(binary(), binary()) -> string().
hex_sha256(Name, Vsn) ->
    %% "https://repo.hex.pm/tarballs/${pkg}-${version}.tar";
    Output = os:cmd(lists:join(" ", [nix_prefetch_url, hex_url(Name, Vsn)])),
    [_, Sha, _] = string:split(Output, "\n", all),
    Sha.

-spec git_sha256(string(), string()) -> string().
git_sha256(Repo, Vsn) ->
    Output = os:cmd(lists:join(" ", [nix_prefetch_git, Repo, "--rev", Vsn])),
    Bin = list_to_binary(Output),
    {match, [_, {Start, Size}]} = re:run(Bin, "\"sha256\": \"([\\w\\d]+)\""),
    <<_:Start/binary, Sha:Size/binary, _/binary>> = Bin,
    binary_to_list(Sha).

-spec hex_url(binary(), binary()) -> string().
hex_url(Name, Vsn) ->
    hex_registry_uri ++ binary_to_list(Name) ++ "-" ++ binary_to_list(Vsn) ++ ".tar".
